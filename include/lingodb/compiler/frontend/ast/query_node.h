#pragma once
#include "ast_node.h"
#include "group_by_node.h"
#include "pipe_operator.h"
#include "result_modifier.h"
#include "table_producer.h"
#include "target_list.h"
#include "../sql_scope.h"

#include <cstdint>
#include <memory>
#include <string>
#define toAsciiASTPrefix                      \
   std::string ast{};                         \
   for (uint32_t i = 0; i < depth - 1; ++i) { \
      ast.append("\t");                       \
                                              \
      ast.append("");                         \
   }                                          \
   ast.append("\t");                          \
   ast.append("└──");
namespace lingodb::ast {
class ExpressionListRef;
enum class QueryNodeType : uint8_t {
   SELECT_NODE = 1,
   SET_OPERATION_NODE = 2,
   BOUND_SET_OPERATION_NODE = 4,
   //BOUND_SUBQUERY_NODE = 5,
   RECURSIVE_CTE_NODE = 6,
   CTE_NODE = 7,
   PIPE_NODE = 8,
   VALUES = 9,
   BOUND_VALUES = 10,
   BOUND_CTE_NODE = 11,

};
class QueryNode : public TableProducer {
   public:
   virtual ~QueryNode() override = default;

   explicit QueryNode(QueryNodeType type) : TableProducer(NodeType::QUERY_NODE), type(type) {};

   //! The type of the query node, either SetOperation or Select
   QueryNodeType type;

   /// The set of result modifiers associated with this query node
   std::vector<std::shared_ptr<ResultModifier>> modifiers{};

   std::shared_ptr<TableProducer> input;

};

class SelectNode : public QueryNode {
   public:
   SelectNode() : QueryNode(TYPE) {}
   static constexpr QueryNodeType TYPE = QueryNodeType::SELECT_NODE;
   //! The projection list
   std::shared_ptr<TargetList> select_list;
   //! The FROM clause
   std::shared_ptr<TableRef> from_clause;
   //! The WHERE clause
   std::shared_ptr<ParsedExpression> where_clause;

   //! list of groups
   std::shared_ptr<GroupByNode> groups;

   //! HAVING clause
   std::shared_ptr<ParsedExpression> having;

   ///For pipe operators
   std::shared_ptr<PipeOperator> startPipeOperator;
   std::shared_ptr<PipeOperator> endPipeOperator;

};

enum class SetOperationType {
   NONE = 0,
   UNION = 1,
   EXCEPT = 2,
   INTERSECT = 3,
   UNION_BY_NAME = 4
};
class SetOperationNode : public QueryNode {
   static constexpr QueryNodeType TYPE = QueryNodeType::SET_OPERATION_NODE;

   public:
   SetOperationNode(SetOperationType setType, std::shared_ptr<TableProducer> left, std::shared_ptr<TableProducer> right) : QueryNode(TYPE), setType(setType), left(left), right(right) {}
   SetOperationType setType;
   bool setOpAll = false;
   std::shared_ptr<TableProducer> left;
   std::shared_ptr<TableProducer> right;

};

//! Represents an expression list as generated by a VALUES statement
class ValuesQueryNode : public QueryNode {
   public:
   static constexpr QueryNodeType TYPE = QueryNodeType::VALUES;
   ValuesQueryNode(std::shared_ptr<ExpressionListRef> expressionListRef) : QueryNode(TYPE), expressionListRef(std::move(expressionListRef)) {}

   //! The expressions in the list
   std::shared_ptr<ExpressionListRef> expressionListRef;
};

class CTENode : public QueryNode {
   public:
   static constexpr const QueryNodeType TYPE = QueryNodeType::CTE_NODE;

   CTENode() : QueryNode(QueryNodeType::CTE_NODE) {}

   std::shared_ptr<TableProducer> query;

   //Maybe use input logic instead
   std::shared_ptr<TableProducer> child;

   std::vector<std::string> columnNames;

};
} // namespace lingodb::ast
