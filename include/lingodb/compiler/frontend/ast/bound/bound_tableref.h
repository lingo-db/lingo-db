#pragma once
#include "bound_expression.h"
#include "lingodb/compiler/frontend/ast/table_producer.h"
#include "lingodb/compiler/frontend/ast/tableref.h"
#include "lingodb/compiler/frontend/sql_scope.h"
namespace lingodb::ast {
class BoundTableRef : public TableProducer {
   public:
   explicit BoundTableRef(TableReferenceType type) : TableProducer(NodeType::BOUND_TABLE_REF), type(type) {
   }
   BoundTableRef(TableReferenceType type, std::string alias) : TableProducer(NodeType::BOUND_TABLE_REF, alias), type(type) {
   }
   TableReferenceType type;
};

class BoundBaseTableRef : public BoundTableRef {
   public:
   static constexpr TableReferenceType TYPE = TableReferenceType::BASE_TABLE;

   BoundBaseTableRef(std::vector<std::shared_ptr<ColumnReference>> columnReferenceEntries, std::string alias, std::string relationName, std::string mlirScope) : BoundTableRef(TYPE, std::move(alias)), columnReferenceEntries(std::move(columnReferenceEntries)), relationName(relationName), mlirScope(mlirScope) {}

   std::vector<std::shared_ptr<ColumnReference>> columnReferenceEntries;
   std::string relationName;
   std::string mlirScope;
};
using boundJoinCond = std::variant<std::shared_ptr<BoundExpression>, std::vector<std::shared_ptr<ColumnRefExpression>>>;
class BoundJoinRef : public BoundTableRef {
   static constexpr TableReferenceType TYPE = TableReferenceType::JOIN;

   public:
   BoundJoinRef(JoinType type, JoinCondType refType, std::shared_ptr<TableProducer> left, std::shared_ptr<TableProducer> right, boundJoinCond condition) : BoundTableRef(TYPE), left(std::move(left)), right(std::move(right)), condition(std::move(condition)), type(type), refType(refType)  {}

   //! The left hand side of the join
   //! QueryNode as variant is needed for pipe syntax. Example: FROM Test |> join ok on id1=id2
   //! Bound left hand
   std::shared_ptr<TableProducer> left;
   //! Bound right hand
   std::shared_ptr<TableProducer> right;

   std::vector<std::shared_ptr<TableProducer>> rights;
   //! The joint condition or a vector of ColumnRefExpression if USING
   boundJoinCond condition;
   //! The join type
   JoinType type;
   //! Join condition type
   JoinCondType refType;

   /**
    * Join attribute mapping for outer joins.
    * first: original attribute ref
    * second: new attribute ref
    */
   std::vector<std::pair<std::shared_ptr<ColumnReference>, std::shared_ptr<ColumnReference>>> outerJoinMapping;

   std::shared_ptr<analyzer::SQLScope> leftScope;
   std::shared_ptr<analyzer::SQLScope> rightScope;
};

class BoundCrossProductRef : public BoundTableRef {
   static constexpr TableReferenceType TYPE = TableReferenceType::CROSS_PRODUCT;
   public:
   BoundCrossProductRef(std::vector<std::shared_ptr<TableProducer>> boundTables) : BoundTableRef(TYPE), boundTables(boundTables) {}
   std::vector<std::shared_ptr<TableProducer>> boundTables;
};

class BoundSubqueryRef : public BoundTableRef {
   static constexpr TableReferenceType TYPE = TableReferenceType::SUBQUERY;

   public:
   BoundSubqueryRef(std::shared_ptr<analyzer::SQLScope> sqlScope, std::shared_ptr<TableProducer> subSelect) : BoundTableRef(TYPE), sqlScope(std::move(sqlScope)), subSelect(std::move(subSelect)) {}

   std::shared_ptr<analyzer::SQLScope> sqlScope;
   //! The subquery
   std::shared_ptr<TableProducer> subSelect;
};
/**
 * Naming consistent with that of DuckDb.
 * Represents an expression list generated by a VALUES statement.
 */
class BoundExpressionListRef : public BoundTableRef {
   public:
   static constexpr TableReferenceType TYPE = TableReferenceType::BOUND_EXPRESSION_LIST;
   BoundExpressionListRef(std::vector<std::vector<std::shared_ptr<BoundConstantExpression>>> values, std::vector<std::shared_ptr<ColumnReference>> columnReferenceEntries) :  BoundTableRef(TYPE), values(std::move(values)), columnReferenceEntries(std::move(columnReferenceEntries)) {}

   //! The expressions in the list
   std::vector<std::vector<std::shared_ptr<BoundConstantExpression>>> values;
   std::vector<std::shared_ptr<ColumnReference>> columnReferenceEntries;
};
} // namespace lingodb::ast